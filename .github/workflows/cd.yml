name: CMS (Wordpress Deployment) - Manual Workflow

on:
  workflow_dispatch:
    branches:
      - main
    inputs:
      shouldCreateVolume:
        description: "Do you want to create Volume?"
        type: boolean
      shouldCreateIngress:
        description: "Do you want to create Ingress?"
        type: boolean
      shouldDeployHelmChart:
        description: "Do you want to deploy Helm Chart?"
        type: boolean

jobs:
  deploy:
    name: Deploy CMS and create required Infrastructure
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.merge_commit_sha }}
          fetch-depth: '0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{vars.REGION}}

      - name: Install eksctl
        run: |
          ARCH=amd64
          PLATFORM=$(uname -s)_$ARCH
          curl -sLO "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_$PLATFORM.tar.gz"
          # (Optional) Verify checksum
          curl -sL "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_checksums.txt" | grep $PLATFORM | sha256sum --check
          tar -xzf eksctl_$PLATFORM.tar.gz -C /tmp && rm eksctl_$PLATFORM.tar.gz
          sudo mv /tmp/eksctl /usr/local/bin

      - name: Create Persistence Volume/Claims for CMS Files
        if: inputs.shouldCreateVolume
        run: |
          eksctl utils write-kubeconfig --cluster ${{vars.CLUSTER}} --region ${{vars.REGION}}
          kubectl create namespace ${{vars.NAMESPACE}} 2>/dev/null || true
          
          # Fetch EFS File System ID
          EFS_FS_ID=$(aws efs describe-file-systems \
            --region ${{vars.REGION}} \
            --output json \
            --query "FileSystems[?contains(CreationToken, 'efs-${{vars.CLUSTER}}')].FileSystemId" \
            --output text)
          
          # Create EFS Access Point
          EFS_AP=$(aws efs create-access-point \
            --file-system-id $EFS_FS_ID \
            --posix-user Uid=1000,Gid=1000 \
            --root-directory "Path=/cms-files,CreationInfo={OwnerUid=1000,OwnerGid=1000,Permissions=777}" \
            --region ${{vars.REGION}} \
            --query 'AccessPointId' \
            --output text)
          
          echo "Access point created"
          
          echo "
          apiVersion: storage.k8s.io/v1
          kind: CSIDriver
          metadata:
              name: efs.csi.aws.com
          spec:
              attachRequired: false
          ---
          kind: StorageClass
          apiVersion: storage.k8s.io/v1
          metadata:
              name: efs-sc
          provisioner: efs.csi.aws.com
          ---
          apiVersion: v1
          kind: PersistentVolume
          metadata:
              name: cms-files-pv
          spec:
              capacity:
                  storage: 50Gi
              volumeMode: Filesystem
              accessModes:
                  - ReadWriteMany
              persistentVolumeReclaimPolicy: Retain
              storageClassName: efs-sc
              csi:
                  driver: efs.csi.aws.com
                  volumeHandle: $EFS_FS_ID::$EFS_AP
          ---
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
              name: cms-files-pvc
          spec:
              accessModes:
                  - ReadWriteMany
              storageClassName: efs-sc
              resources:
                  requests:
                      storage: 25Gi
              volumeName: cms-files-pv
          " | kubectl apply -n ${{vars.NAMESPACE}} -f -

          echo "Persistent Volume for EFS created"

      - name: Create Ingress for External ALB
        if: inputs.shouldCreateIngress
        run: |
          eksctl utils write-kubeconfig --cluster ${{vars.CLUSTER}} --region ${{vars.REGION}}
          kubectl create namespace ${{vars.NAMESPACE}} 2>/dev/null || true

          echo "
          apiVersion: extensions/v1
          kind: Ingress
          metadata:
            name: cms-ingress
            annotations:
              kubernetes.io/ingress.class: "alb"
              alb.ingress.kubernetes.io/scheme: "internet-facing"
              alb.ingress.kubernetes.io/healthcheck-path: "/index.php"
              alb.ingress.kubernetes.io/success-codes: "200,201,302"
              alb.ingress.kubernetes.io/target-type: "ip"
            labels:
              app: cms-ingress
          spec:
            rules:
              - http:
                  paths:
                    - path: /*
                      backend:
                        serviceName: cms
                        servicePort: 80
            " | kubectl apply -n ${{var.NAMESPACE}} -f -

          echo Ingress created"

      - name: helm deploy
        if: inputs.shouldDeployHelmChart
        uses: bitovi/github-actions-deploy-eks-helm@v1.2.4
        with:
          aws-region: ${{vars.REGION}}
          cluster-name: ${{vars.CLUSTER}}
          chart-repository: oci://registry-1.docker.io
          chart-path: bitnamicharts/wordpress
          namespace: ${{vars.NAMESPACE}}
          values: replicaCount=3,persistence.existingClaim=cms-files-pvc,service.type=ClusterIP,resources.requests.cpu=1000m,resources.requests.memory=1024Mi
          name: cms
