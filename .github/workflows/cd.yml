name: CMS (Wordpress Deployment) - Manual Workflow

on:
  workflow_dispatch:
    branches:
      - main
    inputs:
      shouldCreateVolume:
        description: "Do you want to create Volume?"
        type: boolean
      shouldCreateIngress:
        description: "Do you want to create Ingress?"
        type: boolean
      shouldDeployHelmChart:
        description: "Do you want to deploy Helm Chart?"
        type: boolean
env:
  REPLICA_COUNT: 2

jobs:
  deploy:
    name: Deploy CMS and create required Infrastructure
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.merge_commit_sha }}
          fetch-depth: '0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{vars.REGION}}

      - name: Install eksctl
        run: |
          ARCH=amd64
          PLATFORM=$(uname -s)_$ARCH
          curl -sLO "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_$PLATFORM.tar.gz"
          # (Optional) Verify checksum
          curl -sL "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_checksums.txt" | grep $PLATFORM | sha256sum --check
          tar -xzf eksctl_$PLATFORM.tar.gz -C /tmp && rm eksctl_$PLATFORM.tar.gz
          sudo mv /tmp/eksctl /usr/local/bin

      - name: Create Persistence Volume/Claims for CMS Files
        if: inputs.shouldCreateVolume
        run: |
          eksctl utils write-kubeconfig --cluster ${{vars.CLUSTER}} --region ${{vars.REGION}}
          kubectl create namespace ${{vars.NAMESPACE}} 2>/dev/null || true
          
          # Fetch EFS File System ID
          EFS_FS_ID=$(aws efs describe-file-systems \
            --region ${{vars.REGION}} \
            --output json \
            --query "FileSystems[?contains(CreationToken, 'efs-${{vars.CLUSTER}}')].FileSystemId" \
            --output text)
          
          # Create EFS Access Point
          EFS_AP=$(aws efs create-access-point \
            --file-system-id $EFS_FS_ID \
            --posix-user Uid=1000,Gid=1000 \
            --root-directory "Path=/bitnami,CreationInfo={OwnerUid=1000,OwnerGid=1000,Permissions=777}" \
            --region ${{vars.REGION}} \
            --query 'AccessPointId' \
            --output text)
          
          echo "Access point created"
          
          echo "
          apiVersion: storage.k8s.io/v1
          kind: CSIDriver
          metadata:
              name: efs.csi.aws.com
          spec:
              attachRequired: false
          ---
          kind: StorageClass
          apiVersion: storage.k8s.io/v1
          metadata:
              name: efs-sc
          provisioner: efs.csi.aws.com
          ---
          apiVersion: v1
          kind: PersistentVolume
          metadata:
              name: cms-files-pv
          spec:
              capacity:
                  storage: 50Gi
              volumeMode: Filesystem
              accessModes:
                  - ReadWriteMany
              persistentVolumeReclaimPolicy: Retain
              storageClassName: efs-sc
              csi:
                  driver: efs.csi.aws.com
                  volumeHandle: $EFS_FS_ID::$EFS_AP
          ---
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
              name: cms-files-pvc
          spec:
              accessModes:
                  - ReadWriteMany
              storageClassName: efs-sc
              resources:
                  requests:
                      storage: 25Gi
              volumeName: cms-files-pv
          " | kubectl apply -n ${{vars.NAMESPACE}} -f -

          echo "Persistent Volume for EFS created"

      - name: Create Ingress for External ALB
        if: inputs.shouldCreateIngress
        run: |
          eksctl utils write-kubeconfig --cluster ${{vars.CLUSTER}} --region ${{vars.REGION}}
          kubectl create namespace ${{vars.NAMESPACE}} 2>/dev/null || true

          echo "
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: cms-ingress
            annotations:
              kubernetes.io/ingress.class: "alb"
              alb.ingress.kubernetes.io/scheme: "internet-facing"
              alb.ingress.kubernetes.io/healthcheck-path: "/index.php"
              alb.ingress.kubernetes.io/success-codes: "200,201,302"
              alb.ingress.kubernetes.io/target-type: "ip"
            labels:
              app: cms-ingress
          spec:
            rules:
              - http:
                  paths:
                    - path: /*
                      pathType: Prefix  
                      backend:
                        service:
                          name: cms
                          port: 
                            number: 80
            " | kubectl apply -n ${{vars.NAMESPACE}} -f -

          echo "Ingress created"

      - name: Fetch RDS DB Instance Identifier
        if: inputs.shouldDeployHelmChart
        id: dbInstanceIdentifierStep
        run: |
          dbInstanceIdentifier=$(aws rds describe-db-instances --db-instance-identifier ${{vars.CLUSTER}}-db --region ${{vars.REGION}} --query "DBInstances[].Endpoint.Address" --output text)
          echo "Output [$dbInstanceIdentifier]"
          echo "dbInstanceIdentifier=$dbInstanceIdentifier" >> $GITHUB_OUTPUT

      - name: Create DB if it doesn't exist
        if: inputs.shouldDeployHelmChart
        run: |
          # Check if the RDS instance exists
          if aws rds describe-db-instances --output json | jq -r ".DBInstances[] | select(.Endpoint.Address == \"${{steps.dbInstanceIdentifierStep.outputs.dbInstanceIdentifier}}\") | .DBInstanceIdentifier" | grep -q "^${{steps.dbInstanceIdentifierStep.outputs.dbInstanceIdentifier}}$"; then
              echo "RDS instance exists: ${{steps.dbInstanceIdentifierStep.outputs.dbInstanceIdentifier}}"
              # Check if the database already exists within the RDS instance
              if ! aws rds describe-databases --db-instance-identifier ${{steps.dbInstanceIdentifierStep.outputs.dbInstanceIdentifier}} --query "Databases[?DBName=='cms'].DBName" --output text >/dev/null 2>&1; then
                  # Create the new database
                  aws rds create-db \
                    --db-instance-identifier ${{steps.dbInstanceIdentifierStep.outputs.dbInstanceIdentifier}} \
                    --db-name cms \
                    --master-username "${{secrets.MYSQL_MASTER_USER}}" \
                    --master-user-password "${{secrets.MYSQL_MASTER_PASSWORD}}"
                  echo "Database created: cms"
              else
                  echo "Database already exists: cms"
              fi
          else
              echo "RDS instance does not exist: ${{steps.dbInstanceIdentifierStep.outputs.dbInstanceIdentifier}}"
          fi

      - name: helm deploy CMS(Wordpress) chart
        if: inputs.shouldDeployHelmChart
        uses: bitovi/github-actions-deploy-eks-helm@v1.2.4
        with:
          aws-region: ${{vars.REGION}}
          cluster-name: ${{vars.CLUSTER}}
          chart-repository: oci://registry-1.docker.io
          chart-path: bitnamicharts/wordpress
          namespace: ${{vars.NAMESPACE}}
          values: externalDatabase.host=${{steps.dbInstanceIdentifierStep.outputs.dbInstanceIdentifier}},externalDatabase.database=cms,externalDatabase.user=${{secrets.MYSQL_MASTER_USER}},externalDatabase.password=${{secrets.MYSQL_MASTER_PASSWORD}},mariadb.enabled=false,replicaCount=${{env.REPLICA_COUNT}},persistence.existingClaim=cms-files-pvc,service.type=ClusterIP,resources.requests.cpu=1000m,resources.requests.memory=1024Mi
          name: cms
